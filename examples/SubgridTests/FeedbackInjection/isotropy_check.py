################################################################################ This file is part of SWIFT.# Copyright (c) 2025 Darwin Roduit (darwin.roduit@alumni.epl.ch)## This program is free software: you can redistribute it and/or modify# it under the terms of the GNU Lesser General Public License as published# by the Free Software Foundation, either version 3 of the License, or# (at your option) any later version.## This program is distributed in the hope that it will be useful,# but WITHOUT ANY WARRANTY; without even the implied warranty of# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the# GNU General Public License for more details.## You should have received a copy of the GNU Lesser General Public License# along with this program.  If not, see <http://www.gnu.org/licenses/>.###############################################################################import osimport swiftsimio as swfrom tqdm import tqdmimport numpy as npimport matplotlib.pyplot as pltfrom scipy.spatial import distance_matriximport h5py# %%# Define kernel constants based on dimensionalityDIMENSION = 3  # Change this to 2 for 2D or 1 for 1Dif DIMENSION == 1:    kernel_gamma = 1.620185    kernel_constant = 5.0 / 4.0    kernel_coeffs = np.array([0.0, -3.0, 8.0, -6.0, 0.0, 1.0])elif DIMENSION == 2:    kernel_gamma = 1.897367    kernel_constant = 7.0 / np.pi    kernel_coeffs = np.array([4.0, -15.0, 20.0, -10.0, 0.0, 1.0])elif DIMENSION == 3:    kernel_gamma = 1.936492    kernel_constant = 21.0 / (2.0 * np.pi)    kernel_coeffs = np.array([4.0, -15.0, 20.0, -10.0, 0.0, 1.0])kernel_gamma_inv = 1.0 / kernel_gammakernel_gamma_inv_dim = kernel_gamma_inv ** DIMENSIONkernel_gamma_inv_dim_plus_one = kernel_gamma_inv ** (DIMENSION + 1)def wendland_c2(r, h):    """Computes the Wendland C2 kernel function W(r, h)."""    q = r / h    x = q * kernel_gamma_inv    mask = (x < 1.0)  # Valid range    # Horner's method for polynomial evaluation    w = np.zeros_like(q)    # Start with the highest degree term    np.putmask(w, mask, kernel_coeffs[0] * x + kernel_coeffs[1])    for k in range(2, len(kernel_coeffs)):        np.putmask(w, mask, w * x + kernel_coeffs[k])    w = np.maximum(w, 0.0)    w *= kernel_constant * kernel_gamma_inv_dim * h**-DIMENSION    return wdef dwendland_c2(r, h):    """Computes the derivative of the Wendland C2 kernel dW/dr."""    q = r / h    x = q * kernel_gamma_inv    mask = (x < 1.0)  # Valid range    # Start from the highest power term    w = np.zeros_like(q)    dw_dx = np.zeros_like(q)    # Start with the highest degree term    np.putmask(w, mask, kernel_coeffs[0] * x + kernel_coeffs[1])    np.putmask(dw_dx, mask, kernel_coeffs[0])  # Highest power coefficient    # Apply Horner's method correctly (descending order)    # Skip last constant term (derivative of constant is 0)    for k in range(2, len(kernel_coeffs)):        np.putmask(dw_dx, mask, dw_dx * x + w)        np.putmask(w, mask, w * x + kernel_coeffs[k])    dw_dx = np.minimum(dw_dx, 0.0)    dw_dx *= kernel_constant * \        kernel_gamma_inv_dim_plus_one * h**(-(DIMENSION + 1))    return dw_dx# %%def list_snapshots(folder_path):    """Lists all snapshot files in the folder."""    snapshots = [        os.path.join(folder_path, f)        for f in os.listdir(folder_path)        if f.startswith("snapshot_") and f.endswith(".hdf5")    ]    return sorted(snapshots)def number_density(positions, smoothing_lengths, target_indices):    """    Compute number density only for selected particles.    Parameters:    - positions: (N, 3) array of all particle positions.    - smoothing_lengths: (N,) array of smoothing lengths for all particles.    - target_indices: List or array of indices of particles to compute the number density for.    Returns:    - densities: (len(target_indices),) array of number densities for selected particles.    """    target_positions = positions[target_indices]  # Select target particle positions    # Corresponding smoothing lengths    target_smoothing = smoothing_lengths[target_indices]    # Compute distances (len(target_indices), N)    r_ij = distance_matrix(target_positions, positions)    # Compute kernel values (applying smoothing length scaling)    # Shape (len(target_indices), N)    kernel_values = wendland_c2(r_ij, target_smoothing[:, None])    # Sum contributions for each selected particle    densities = np.sum(kernel_values, axis=1)    return densitiesdef number_density_stars(star_positions, star_smoothing_lengths, gas_positions):    """    Compute number density for star particles using only gas particles,    applying the star's smoothing length.    Parameters:    - star_positions: (Ns, 3) array of star particle positions.    - star_smoothing_lengths: (Ns,) array of smoothing lengths for star particles.    - gas_positions: (Ng, 3) array of gas particle positions.    Returns:    - densities: (Ns,) array of number densities for star particles.    """    # Compute distances between stars and gas (Ns, Ng)    r_ij = distance_matrix(star_positions, gas_positions)    # Compute kernel values (applying smoothing length scaling)    kernel_values = wendland_c2(        r_ij, star_smoothing_lengths[:, None])  # Shape (Ns, Ng)    # Sum contributions for each star particle    densities = np.sum(kernel_values, axis=1)    return densitiesdef compute_face_area(star_position, gas_position, star_smoothing_length, gas_smoothing_length, n_star_density, n_gas_density):    """    Compute the face area using the Wendland C2 kernel.    Parameters:    - star_position: (Ns, 3) array of star particle positions.    - gas_position: (Ng, 3) array of gas particle positions.    - star_smoothing_length: (Ns,) array of smoothing lengths for stars.    - gas_smoothing_length: (Ng,) array of smoothing lengths for gas.    - n_star_density: (Ns,) array of number densities for stars.    - n_gas_density: (Ng,) array of number densities for gas.    Returns:    - face_area: (Ns, Ng, 3) array representing the computed face areas.    """    # Convert to NumPy arrays    star_position = np.asarray(star_position)    gas_position = np.asarray(gas_position)    # Compute pairwise distances (Ns, Ng)    r_ij = np.linalg.norm(        star_position[:, None, :] - gas_position[None, :, :], axis=-1)  # Shape (Ns, Ng)    # Compute unit vector r_ij / |r_ij| safely    unit_vector = (gas_position[None, :, :] - star_position[:, None, :]) / \        np.where(r_ij[..., None] > 0, r_ij[..., None], 1)  # Shape (Ns, Ng, 3)    # Compute gradients of the Wendland C2 kernel correctly    grad_w_star = np.abs(dwendland_c2(        r_ij, star_smoothing_length[:, None]))  # Shape (Ns, Ng)    grad_w_gas = np.abs(dwendland_c2(        r_ij, gas_smoothing_length[None, :]))    # Shape (Ns, Ng)    # **Ensure n_star_density and n_gas_density are broadcastable**    n_star_density = n_star_density[:, None]  # Shape (Ns, 1)    n_gas_density = n_gas_density[None, :]    # Shape (1, Ng)    # Compute face area with correct broadcasting    face_area_vector = ((grad_w_star / (n_star_density**2)) + (grad_w_gas /                        (n_gas_density**2)))[:, :, None] * unit_vector  # Shape (Ns, Ng, 3)    # Compute the norm (magnitude) of the face area    face_area_norm = np.linalg.norm(        face_area_vector, axis=2).flatten()  # Shape (Ng)    return face_area_normdef compute_flux_by_cos_theta(star_position, neighbor_positions, neighbor_fluxes, n_bins=50):    """Compute the metal flux as a function of |cos(theta)|."""    rel_positions = neighbor_positions - star_position    z = rel_positions[:, 2]    distances = np.linalg.norm(rel_positions, axis=1)    abs_cos_theta = np.abs(z / distances)    cos_theta_bins = np.linspace(0, 1, n_bins + 1)    cos_theta_midpoints = 0.5 * (cos_theta_bins[:-1] + cos_theta_bins[1:])    metal_flux_hist, _ = np.histogram(        abs_cos_theta, bins=cos_theta_bins, weights=neighbor_fluxes)    return cos_theta_midpoints, metal_flux_histdef compute_solid_angle(star_position, neighbor_positions, face_area):    """Compute the solid angle subtended by each gas particle relative to the star."""    rel_positions = neighbor_positions - star_position    distances = np.linalg.norm(rel_positions, axis=1)    solid_angles = face_area / distances**2    return solid_angles# %%if __name__ == "__main__":    # Parent directory containing multiple runs    base_folders = ["./GEAR_MECH1", "./GEAR"]    plot_labels = ["Mechanical", "GEAR"]    colors = ["red", "blue"]    data_output_filename = "isotropy_check_data.hdf5"    simulation_names = ["Mechanical", "GEAR"]    all_simulations_metal_flux_hists = []    for base_folder in base_folders:        run_folders = sorted([os.path.join(base_folder, d) for d in os.listdir(            base_folder) if os.path.isdir(os.path.join(base_folder, d))])        all_metal_flux_hists = []        if not run_folders:            print(f"No simulation folders found in {base_folder}.")        else:            print(f"Found {len(run_folders)} simulation runs.")            for run_folder in tqdm(run_folders, desc="Processing simulations"):                folder_path = os.path.join(run_folder, "snap")                snapshots = list_snapshots(folder_path)                if not snapshots:                    print(f"No snapshots found in {folder_path}. Skipping.")                    continue                # Find first snapshot where feedback occurs                for index, snapshot in enumerate(snapshots):                    data = sw.load(snapshot)                    if np.sum(data.gas.metal_mass_fractions.metals) > 0:                        # Find the particles ids that received feedback at injection time and get the metals                        I = np.argwhere(                            data.gas.metal_mass_fractions.metals > 0).flatten()                        m_metals = data.gas.metal_mass_fractions.metals[I] * \                            data.gas.masses[I]                        ids = data.gas.particle_ids[I]                        # Get the snapshots                        snapshot_injection = snapshot                        snapshot_injection_1 = snapshots[index-1]                        break                ###################################                # Now do data analysis                # Load the data                data = sw.load(snapshot_injection)                # Get the index of the particles ids touched by feedback (i.e. received metals)                I = np.isin(data.gas.particle_ids, ids)                # Get the relevant data                star_pos = data.stars.coordinates                pos = data.gas.coordinates[I, :]                h_gas = data.gas.smoothing_lengths[I]                h_star = data.stars.smoothing_lengths                # Compute face area                pos_all_gas = data.gas.coordinates                n_gas_density = number_density(                    pos_all_gas.value, data.gas.smoothing_lengths.value, I)                n_star_density = number_density_stars(                    star_pos.value, h_star.value, pos_all_gas.value)                face_area = compute_face_area(                    star_pos.value, pos.value, h_star.value, h_gas.value, n_star_density, n_gas_density)                # Keep only non zero face area.                # Note: During the simulation, if this happens, then no flux is                # distributed. However, since we are recomputing the face areas at                # a fixed snapshot time that is different from the timestep at which                # the feedback did it's computations, we can have a mismatch.                mask = face_area > 0                solid_angles = compute_solid_angle(star_pos, pos, face_area)                m_metals_flux = m_metals / solid_angles                # Do an histogram                cos_theta_midpoints, metal_flux_hist = compute_flux_by_cos_theta(                    star_pos, pos[mask], m_metals_flux[mask], 20)                all_metal_flux_hists.append(metal_flux_hist)            all_simulations_metal_flux_hists.append(all_metal_flux_hists)# %%    # Plot    fig, ax = plt.subplots()    ax.set_xlabel(r"$|\cos(\theta)|$", fontsize=14)    ax.set_ylabel("Metal Flux", fontsize=14)    for metal_flux_hist, plot_label, color in zip(all_simulations_metal_flux_hists, plot_labels, colors):        # Compute mean and standard deviation        median_flux_hist = np.median(metal_flux_hist, axis=0)        std_flux_hist = np.std(metal_flux_hist, axis=0)        # Plot        ax.plot(cos_theta_midpoints, median_flux_hist,                label=plot_label, color=color, linewidth=2)    ax.legend(fontsize=12)    ax.grid(True, linestyle="--", alpha=0.6)    fig.tight_layout()    plt.show()    plt.savefig("isotropy_check_comparison.png",                format="png", bbox_inches='tight', dpi=300)    # Write the data    with h5py.File(data_output_filename, "w") as f:        for i, simulation in enumerate(simulation_names):            simulation_group = f.create_group(simulation)            if "metal_flux_hist" in simulation_group:                # Assign values from output                f.create_dataset("metal_flux_hist",                                 data=all_simulations_metal_flux_hists[i])                f.create_dataset("cos_theta", data=cos_theta_midpoints)