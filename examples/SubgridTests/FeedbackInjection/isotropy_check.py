import osimport swiftsimio as swfrom tqdm import tqdmimport numpy as npimport matplotlib.pyplot as pltfrom scipy.spatial import distance_matrix#%%# Define kernel constants based on dimensionalityDIMENSION = 3  # Change this to 2 for 2D or 1 for 1Dif DIMENSION == 1:    kernel_gamma = 1.620185    kernel_constant = 5.0 / 4.0    kernel_coeffs = np.array([0.0, -3.0, 8.0, -6.0, 0.0, 1.0])elif DIMENSION == 2:    kernel_gamma = 1.897367    kernel_constant = 7.0 / np.pi    kernel_coeffs = np.array([4.0, -15.0, 20.0, -10.0, 0.0, 1.0])elif DIMENSION == 3:    kernel_gamma = 1.936492    kernel_constant = 21.0 / (2.0 * np.pi)    kernel_coeffs = np.array([4.0, -15.0, 20.0, -10.0, 0.0, 1.0])kernel_gamma_inv = 1.0 / kernel_gammakernel_gamma_inv_dim = kernel_gamma_inv ** DIMENSIONkernel_gamma_inv_dim_plus_one = kernel_gamma_inv ** (DIMENSION + 1)def wendland_c2(r, h):    """Computes the Wendland C2 kernel function W(r, h)."""    q = r / h    x = q * kernel_gamma_inv    mask = (x < 1.0)  # Valid range    # Horner's method for polynomial evaluation    w = np.zeros_like(q)    np.putmask(w, mask, kernel_coeffs[0] * x + kernel_coeffs[1])  # Start with the highest degree term        for k in range(2, len(kernel_coeffs)):          np.putmask(w, mask, w * x + kernel_coeffs[k])    w = np.maximum(w, 0.0)     w *= kernel_constant * kernel_gamma_inv_dim * h**-DIMENSION    return wdef dwendland_c2(r, h):    """Computes the derivative of the Wendland C2 kernel dW/dr."""    q = r / h    x = q * kernel_gamma_inv    mask = (x < 1.0)  # Valid range    # Start from the highest power term    w = np.zeros_like(q)    dw_dx = np.zeros_like(q)    np.putmask(w, mask, kernel_coeffs[0] * x + kernel_coeffs[1])  # Start with the highest degree term    np.putmask(dw_dx, mask, kernel_coeffs[0])  # Highest power coefficient    # Apply Horner's method correctly (descending order)    for k in range(2, len(kernel_coeffs)):  # Skip last constant term (derivative of constant is 0)        np.putmask(dw_dx, mask, dw_dx * x + w)        np.putmask(w, mask, w * x + kernel_coeffs[k])    dw_dx = np.minimum(dw_dx, 0.0)    dw_dx *= kernel_constant * kernel_gamma_inv_dim_plus_one * h**(-(DIMENSION + 1))    return dw_dx#%%def list_snapshots(folder_path):    """Lists all snapshot files in the folder."""    snapshots = [        os.path.join(folder_path, f)        for f in os.listdir(folder_path)        if f.startswith("snapshot_") and f.endswith(".hdf5")    ]    return sorted(snapshots)def number_density(positions, smoothing_lengths, target_indices):    """    Compute number density only for selected particles.        Parameters:    - positions: (N, 3) array of all particle positions.    - smoothing_lengths: (N,) array of smoothing lengths for all particles.    - target_indices: List or array of indices of particles to compute the number density for.    Returns:    - densities: (len(target_indices),) array of number densities for selected particles.    """    target_positions = positions[target_indices]  # Select target particle positions    target_smoothing = smoothing_lengths[target_indices]  # Corresponding smoothing lengths    # Compute distances (len(target_indices), N)    r_ij = distance_matrix(target_positions, positions)    # Compute kernel values (applying smoothing length scaling)    kernel_values = wendland_c2(r_ij, target_smoothing[:, None])  # Shape (len(target_indices), N)    # Sum contributions for each selected particle    densities = np.sum(kernel_values, axis=1)    return densitiesdef number_density_stars(star_positions, star_smoothing_lengths, gas_positions):    """    Compute number density for star particles using only gas particles,     applying the star's smoothing length.        Parameters:    - star_positions: (Ns, 3) array of star particle positions.    - star_smoothing_lengths: (Ns,) array of smoothing lengths for star particles.    - gas_positions: (Ng, 3) array of gas particle positions.    Returns:    - densities: (Ns,) array of number densities for star particles.    """    # Compute distances between stars and gas (Ns, Ng)    r_ij = distance_matrix(star_positions, gas_positions)    # Compute kernel values (applying smoothing length scaling)    kernel_values = wendland_c2(r_ij, star_smoothing_lengths[:, None])  # Shape (Ns, Ng)        # Sum contributions for each star particle    densities = np.sum(kernel_values, axis=1)    return densitiesdef compute_face_area(star_position, gas_position, star_smoothing_length, gas_smoothing_length, n_star_density, n_gas_density):    """    Compute the face area using the Wendland C2 kernel.        Parameters:    - star_position: (Ns, 3) array of star particle positions.    - gas_position: (Ng, 3) array of gas particle positions.    - star_smoothing_length: (Ns,) array of smoothing lengths for stars.    - gas_smoothing_length: (Ng,) array of smoothing lengths for gas.    - n_star_density: (Ns,) array of number densities for stars.    - n_gas_density: (Ng,) array of number densities for gas.    Returns:    - face_area: (Ns, Ng, 3) array representing the computed face areas.    """    # Convert to NumPy arrays    star_position = np.asarray(star_position)    gas_position = np.asarray(gas_position)    # Compute pairwise distances (Ns, Ng)    r_ij = np.linalg.norm(star_position[:, None, :] - gas_position[None, :, :], axis=-1)  # Shape (Ns, Ng)    # Compute unit vector r_ij / |r_ij| safely    unit_vector = (gas_position[None, :, :] - star_position[:, None, :]) / np.where(r_ij[..., None] > 0, r_ij[..., None], 1)  # Shape (Ns, Ng, 3)    # Compute gradients of the Wendland C2 kernel correctly    grad_w_star = np.abs(dwendland_c2(r_ij, star_smoothing_length[:, None]))  # Shape (Ns, Ng)    grad_w_gas = np.abs(dwendland_c2(r_ij, gas_smoothing_length[None, :]))    # Shape (Ns, Ng)    # **Ensure n_star_density and n_gas_density are broadcastable**    n_star_density = n_star_density[:, None]  # Shape (Ns, 1)    n_gas_density = n_gas_density[None, :]    # Shape (1, Ng)    # Compute face area with correct broadcasting    face_area_vector = ((grad_w_star / (n_star_density**2)) + (grad_w_gas / (n_gas_density**2)))[:, :, None] * unit_vector  # Shape (Ns, Ng, 3)    # Compute the norm (magnitude) of the face area    face_area_norm = np.linalg.norm(face_area_vector, axis=2).flatten()  # Shape (Ng)        return face_area_normdef compute_flux_by_cos_theta(star_position, neighbor_positions, neighbor_fluxes, n_bins=50):    """Compute the metal flux as a function of |cos(theta)|."""    rel_positions = neighbor_positions - star_position    z = rel_positions[:, 2]    distances = np.linalg.norm(rel_positions, axis=1)    abs_cos_theta = np.abs(z / distances)    cos_theta_bins = np.linspace(0, 1, n_bins + 1)    cos_theta_midpoints = 0.5 * (cos_theta_bins[:-1] + cos_theta_bins[1:])    metal_flux_hist, _ = np.histogram(abs_cos_theta, bins=cos_theta_bins, weights=neighbor_fluxes)    return cos_theta_midpoints, metal_flux_histdef compute_solid_angle(star_position, neighbor_positions, face_area):    """Compute the solid angle subtended by each gas particle relative to the star."""    rel_positions = neighbor_positions - star_position    distances = np.linalg.norm(rel_positions, axis=1)    solid_angles = face_area / distances**2    return solid_angles#%%if __name__ == "__main__":    base_folder = "./GEAR_MECH1"  # Parent directory containing multiple runs    # base_folder = "./GEAR"  # Parent directory containing multiple runs    run_folders = sorted([os.path.join(base_folder, d) for d in os.listdir(base_folder) if os.path.isdir(os.path.join(base_folder, d))])    # run_folders = ['./GEAR_MECH1/run_5']    # run_folders = ['./']    all_metal_flux_hists = []        if not run_folders:        print(f"No simulation folders found in {base_folder}.")    else:        print(f"Found {len(run_folders)} simulation runs.")        for run_folder in tqdm(run_folders, desc="Processing simulations"):            folder_path = os.path.join(run_folder, "snap")            snapshots = list_snapshots(folder_path)                        if not snapshots:                print(f"No snapshots found in {folder_path}. Skipping.")                continue                        # Find first snapshot where feedback occurs            for index, snapshot in enumerate(snapshots):                data = sw.load(snapshot)                if np.sum(data.gas.metal_mass_fractions.metals) > 0:                                        # Find the particles ids that received feedback at injection time and get the metals                    I = np.argwhere(data.gas.metal_mass_fractions.metals > 0).flatten()                    m_metals = data.gas.metal_mass_fractions.metals[I] * data.gas.masses[I]                    ids = data.gas.particle_ids[I]                                        # Get the snapshots                    snapshot_injection = snapshot                    snapshot_injection_1 = snapshots[index-1]                    break                        ###################################            # Now do data analysis                        # Load the data            data = sw.load(snapshot_injection)                        # Get the index of the particles ids touched by feedback (i.e. received metals)            I = np.isin(data.gas.particle_ids, ids)                        # Get the relevant data            star_pos = data.stars.coordinates            pos = data.gas.coordinates[I, :]            h_gas = data.gas.smoothing_lengths[I]            h_star = data.stars.smoothing_lengths                        # Compute face area            pos_all_gas = data.gas.coordinates            n_gas_density = number_density(pos_all_gas.value, data.gas.smoothing_lengths.value, I)            n_star_density = number_density_stars(star_pos.value, h_star.value, pos_all_gas.value)            face_area = compute_face_area(star_pos.value, pos.value, h_star.value, h_gas.value, n_star_density, n_gas_density)                        # Keep only non zero face area.            # Note: During the simulation, if this happens, then no flux is             # distributed. However, since we are recomputing the face areas at             # a fixed snapshot time that is different from the timestep at which             # the feedback did it's computations, we can have a mismatch.            mask = face_area > 0            solid_angles = compute_solid_angle(star_pos, pos, face_area)            m_metals_flux = m_metals / solid_angles            # Do an histogram            cos_theta_midpoints, metal_flux_hist = compute_flux_by_cos_theta(star_pos, pos[mask], m_metals_flux[mask], 15)            all_metal_flux_hists.append(metal_flux_hist)        # Compute mean and standard deviation        median_flux_hist = np.median(all_metal_flux_hists, axis=0)        std_flux_hist = np.std(all_metal_flux_hists, axis=0)#%%        # Plot        fig, ax = plt.subplots()        ax.plot(cos_theta_midpoints, median_flux_hist, label="Median Metal Flux", color="red", linewidth=2)        ax.set_xlabel(r"$|\cos(\theta)|$", fontsize=14)        ax.set_ylabel("Metal Flux", fontsize=14)        ax.legend(fontsize=12)        ax.grid(True, linestyle="--", alpha=0.6)        fig.tight_layout()        plt.show()